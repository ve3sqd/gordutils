#!/usr/bin/python3

import os
import sys
import random
import hashlib
import shutil
import pickle
import locale



# set the locale and module path
locale.setlocale(locale.LC_ALL, '')
my_homedir = os.path.expanduser("~")
sys.path.insert(0, os.path.join(my_homedir, 'python/imports'))



#---------------------------------------------------------------------------------------------------------
#  Declaration of global variables
#---------------------------------------------------------------------------------------------------------

# generic 
search_directory = '' #base directory for file operations (set first time or from menu)
move_to_directory = ''     #move here instead of deleting
#--------------------------------------------------------------------------------------------------
# process duplicate filenames
fullfilelist=[]     #contains all of the filepaths in the search directories
dupset=set()        #contains all of the duplicate filenames (non repeated)
all_dups={}         #contains a dictionary of filenumber/filepath pairs
refresh_filelist_req = 1  #do we need to refresh the file list?
#---------------------------------------------------------------------------------------------------
# process duplicate checksums
checksum_dict = {}
chosen_checksum = 0


             
def display_main_menu():        

     '''print out the main menu choices

     Arguments:  none

     Returns: none

     ''' 
     fmt = '{0:>3s} {1}'
     print("\nGORD'S FILE UTILITIES")
     print(fmt.format('1.', 'Process duplicate filenames'))
     print(fmt.format('2.', 'Process duplicate checksums'))
     print(fmt.format('3.', 'Delete files with a specific extension and size'))
     print(fmt.format('4.', 'Remove empty directories'))
     print(fmt.format('5.', 'Display file information'))
     print(fmt.format('6.', 'Stack by filetype'))
     print(fmt.format('7.', 'Move/copy files'))
     print(fmt.format('8.', 'Change active directory'))
     print(fmt.format('9.', 'Print active directory'))
     print(fmt.format('10.', 'Checkout filetype'))
     print(fmt.format('11.', 'Checkin filetype'))
     print(fmt.format('12.', 'Quit'))   


def get_main_choice():
     
     '''Ask the user to make a main menu choice and validates it.  The input must be a number.

     Arguments: none

     Returns: the user input as a number

     '''
     myinput=0
     main_valid_choice=(1,2,3,4,5,6,7,8,9,10,11,12)      #contains all of the valid main menu choices
     while myinput not in main_valid_choice:
          display_main_menu()
          myinput = input('\nEnter choice: ')
          try:
               myinput = int(myinput)
          except:
               pass
     return myinput


def execute_main_choice(choice):
     
     '''Main menu branching point - call the appropriate function based on user input

     Arguments: the menu choice entered by the user (from get_main_choice())

     Returns:  none

     '''
     if choice == 1:
          process_dup_filenames()
     elif choice == 2:
          process_checksums()
     elif choice == 3:
          process_extension()
     elif choice == 4:
          remove_empty_directories(root_dir = search_directory)
     elif choice == 5:
          display_file_stats()
     elif choice == 6:
          stack_filetypes()
     elif choice == 7:
          move_or_copy_files()
     elif choice == 8:
          change_active_directory()
     elif choice == 9:
          print_working_directory()
     elif choice == 10:
          checkout_files()
     elif choice == 11:
          checkin_files()
     elif choice == 12:
          sys.exit(0);
          

#---------------------------------------------------------------------------------------------------
#  Process duplicate filenames
#---------------------------------------------------------------------------------------------------

def process_dup_filenames():

     '''Master function for process duplicate filenames - call functions in required order

     Arguments: none

     Returns:  none

     '''
     global refresh_filelist_req
     refresh_filelist_req = 1
     find_dups()    #populate dupset and fileset
     populate_dict_all_dups_and_display() #show onscreen the files from one duplicate filename
     execute_file_action_choice(get_file_action_menu_choice())
     
     

def find_dups(print_stats = True):

     '''populates a list of all of the files in the base directory (recursively) into list fullfilelist and
        populates a set called dupset that contains all of the duplicate filenames (w/o regard to the path)
	Also populates a set called fileset that contains all of the unique filenames in the filesystem

     Arguments: optional argument print_stats prints out statistics if True

     Returns: the total number of files in the filesystem and the total number of unique filenames 

     '''
     global refresh_filelist_req, dupset
     fileset=set()       #contains all filenames from disk (no duplicates because it's a set)     
     dupset.clear()     
     if refresh_filelist_req:
          populate_fullfilelist(search_directory)
     refresh_filelist_req = 0     
     setlength=len(fileset)
     for x in range(len(fullfilelist)):
          (dirname, filename) = os.path.split(fullfilelist[x])
          fileset.add(filename)
          if setlength == len(fileset):
               dupset.add(filename)
          else:
               setlength += 1
     if print_stats:
          print_dup_stats(len(fullfilelist), len(fileset))
     return (len(fullfilelist), len(fileset))

     
     
def print_dup_stats(all_files, unique_files):    
    
     '''Simply prints file statistics to the screen

     Arguments: all_files = total # of files (recursive) in the filesystem
                unique_files = total # of unique filenames (w/o regard to path) in the filesystem

     Returns:  none
     
     '''
     print('\n{0:32s} {1:n}'.format('Number of files: ', all_files))
     print('{0:32s} {1:n}'.format('Number of unique filenames: ',unique_files))
     print('{0:32s} {1:n}\n'.format('Number of duplicate filenames:', all_files - unique_files))
     
                     

def populate_dict_all_dups_and_display():    

     '''populate a dictionary called all_dups (global)
        The key is a number (starting at 1) and the item is a randomly chosen filename from the set dupset
	This dictionary is used to display all of the duplicates and allow the user to choose an action on them
	This function calls display_all_dups to display the duplicate chosen
	This function is called when a new list of duplicate filenames needs to be created and displayed on the screen

     Arguments:  none

     Return:  none

     '''
     global all_dups     
     all_dups.clear()    #all_dups is a global dictionary of number:filepath pairs
     if len(dupset) == 0:
          print('\nNo duplicates found!!\n')          
          return             
     counter = 0
     print()
     current_processing_duplicate = random.sample(dupset,1)[0]
     print(60*'-','DUPLICATE FILENAME DELETE\n')     
     print('processing',current_processing_duplicate)
     for x in range(len(fullfilelist)):
          (dirname, filename) = os.path.split(fullfilelist[x])
          if filename == current_processing_duplicate:
               counter += 1
               all_dups[counter] = fullfilelist[x]
     display_all_dups()
   


def display_all_dups():

     '''Display all the duplicates for that filename together with duplicate number, filesize, and sha1 checksum
        This function is called when the current list of duplicates just needs to be redisplayed (after some file action by the user)

     Arguments: none

     Returns: none

     '''
     start_pos = len(my_homedir) + 1
     if len(all_dups) > 0:
          for x in all_dups:
                    #print the number, full filename, size of the file in bytes, and checksum
                    dir_name = all_dups[x][start_pos:]     #remove the first 2 directories from the path to make it shorter
                    print('{0:3d} {1:161s} {2:15d} {3}'.format(x, dir_name, os.path.getsize(all_dups[x]), compute_sha1(all_dups[x])))
          print()
     else:
          print('\nNo duplicates found!!\n')



def reset_all_dup_keys():   

     '''when a duplicate is deleted by the user, the keys need to be re-numbered so they range from 1 to the
        new number of duplicates (i.e. close the number gap after a delete)

     Arguments:  none

     Returns:  none

     '''
     global all_dups
     keypos = 0
     for key in all_dups:
          keypos += 1
          all_dups[keypos] = all_dups.pop(key)
         

def get_file_action_menu_choice():

     '''Accept and validate input for the action to perform for duplicate file processing

     Arguments:  none

     Returns:  return the choice selected

     '''
     valid_choice_entered = 0
     myinput=0
     if len(dupset) == 0:          
          return 'm'     #return to the main menu if there are no duplicates to process
     while not valid_choice_entered:
          display_file_action_instructions()
          myinput = input('\nEnter choice: ')
          if len(myinput) > 0:
               if myinput in ['n','m','dall']:
                     valid_choice_entered = 1
               elif myinput[0] == 'd':
                    try:
                         mynumber = int(myinput[1:])
                    except:
                         valid_choice_entered = 0
                    else:
                         if mynumber > 0 and mynumber <= len(all_dups):
                              valid_choice_entered = 1
                         else:
                              print('\nvalue entered is out of range\n')
                         
               elif myinput[0] in ('k', 'p'):
                    try:
                         mynumber = int(myinput[1:])
                    except:
                         valid_choice_entered = 0
                    else:
                         if mynumber > 0 and mynumber <= len(all_dups):
                              valid_choice_entered = 1
                         else:
                              print('\nvalue entered is out of range\n')
               
               elif myinput[0] == 'r':
                    valid_choice_entered = 1
               else:
                    valid_choice_entered = 0
     return myinput     
     
     
def execute_file_action_choice(mychoice):

     '''Depending on the choice entered for the current duplicate filename list, 
        call the appropriate function to handle the request
	Note that this function is recursive and calls itself repeatedly (not sure I like this - may rewrtie non-recursively)

     Arguments:  the action choice entered by the user (dall, m, n, k3, etc.)

     Returns:  none

     '''
     if mychoice == 'n': #user wants to display the next duplicate set
          populate_dict_all_dups_and_display() #show onscreen the files for one duplicate filename
          execute_file_action_choice(get_file_action_menu_choice())
     elif mychoice == 'dall':
          delete_all_files()
          populate_dict_all_dups_and_display() #show onscreen the files for one duplicate filename
          execute_file_action_choice(get_file_action_menu_choice())
     elif mychoice == 'm':
          print('\nreturning to main menu...')
     elif mychoice[0] == 'd': #user selects to delete a single file
          delete_single_file(int(mychoice[1:]))
          if len(all_dups) == 0:
               print('\nFilename no longer exists on the disk\n')
               populate_dict_all_dups_and_display() #show onscreen the files for one duplicate filename
               execute_file_action_choice(get_file_action_menu_choice())
          else:    
               display_all_dups()
               execute_file_action_choice(get_file_action_menu_choice())
     elif mychoice[0] == 'k':
          keep_one_only(int(mychoice[1:]))
          display_all_dups()
          execute_file_action_choice(get_file_action_menu_choice())
     elif mychoice[0] == 'p':
          play_choice(all_dups[int(mychoice[1:])])
          execute_file_action_choice(get_file_action_menu_choice())
     elif mychoice[0] == 'r':
          display_all_dups()
          execute_file_action_choice(get_file_action_menu_choice())
     else:
          print('Unknown response')
          display_all_dups()
          execute_file_action_choice(get_file_action_menu_choice())

     
     

def delete_single_file(file_number):

     '''When the user select to delete a particular file, this function is called
        After deletion it cleans up fullfilelist, all_dups, and dupset, as well as renumbering the remaining choices

     Arguments:  The file number selected (which is the all_dups key)

     Returns:  none

     '''
     #define my_filepath and filename
     my_filepath = all_dups[file_number]
     (dirname, filename) = os.path.split(my_filepath)
     print('\ndeleting ',my_filepath)
     print()     
     #delete_item_from_disk(my_filepath)
     move_copy_file('move', my_filepath, move_to_directory)
     remove_entry_from_fullfilelist(my_filepath)
     remove_entry_from_all_dups(file_number)
     reset_all_dup_keys()
     if len(all_dups) in (0, 1):  #this file is no longer a duplicate     
          remove_entry_from_dupset(filename)
     
            
     
def keep_one_only(file_number):    

     '''When the user chooses to keep only one file, this function is called
        It deletes all of the other files, then cleans up all_dups and dupset

     Arguments:  the file number chosen by the user

     Returns:  none

     '''
     global all_dups
     if len(all_dups) == 0:
          print('\nNothing to delete!')
          return
     (dirname, filename) = os.path.split(all_dups[1])
     print()
     my_saved_item = all_dups.pop(file_number)     
     for x in all_dups:
          my_filepath = all_dups[x]
          print('deleting ',my_filepath)          
          move_copy_file('move', my_filepath, move_to_directory)
          remove_entry_from_fullfilelist(my_filepath)                    
     print()
     all_dups.clear()
     all_dups[1] = my_saved_item
     remove_entry_from_dupset(filename)


def delete_all_files():  
     '''When the user enters 'dall', this function is called
        It deletes all files in all_dups, then cleans up dupset and fullfilelist

     Arguments: none

     Returns: none

     '''
     if len(all_dups) == 0:
          print('\nNothing to delete!')
          return
     (dirname, filename) = os.path.split(all_dups[1])
     print()
     for x in all_dups:
          my_filepath = all_dups[x]
          print('deleting ',my_filepath)
          move_copy_file('move', my_filepath, move_to_directory)
          remove_entry_from_fullfilelist(my_filepath)
     remove_entry_from_dupset(filename)


def remove_entry_from_all_dups(dupkey):

     '''Utility function to remove a file from the all_dups dictionary

     Arguments: the key of the entry to delete from all_dups

     Returns:  none

     '''
     global all_dups
     try:
          all_dups.pop(dupkey)
     except:
          print('Error while removing deleted item from all_dups')
          print('exiting...')
          sys.exit(2)



def remove_entry_from_dupset(entry):

     '''''Utility function to remove a filename from the dupset set

     Arguments:  the filename (w/o path) to remove

     Returns: none

     '''
     global dupset
     if entry in dupset:
          dupset.remove(entry)




#------------------------------------------------------------------------------------------------------------
#  Process checksums
#------------------------------------------------------------------------------------------------------------

#This section processes files that have the same checksum.  It is almost identical to the dulicate filename
#section but works instead on files with the same checksum.



def process_checksums():     

     '''Main function to call the other functions in the required order

     Arguments: none

     Returns:  none

     '''
     create_update_checksum_dict()
     display_single_checksum_files()
     if chosen_checksum != -1:
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())
     else:
          print('returning to main menu...')
     
     
def create_update_checksum_dict(verbose_mode = True):

     '''Since it takes a while to calculate checksums on all of the files, once they are calculated they are stored
        in a file containing a dump of the checksum_dict dictionary
	This function determines if the checksum file exists on disk and creates it if it doesn't
	If the checksum already exists, it reads it in, then updates the checksum_dict dictionary to add or remove files as necessary
	The filename is based on the path to the base directory and is an object created by pickle

     Arguments:  optional argument verbose_mode can be set to false to suppress print output from the function

     Returns: none

     '''
     global checksum_dict    
     obj_dir = os.path.join(my_homedir,'.gordutils')
     dict_name = replace_slash_with_underscore(search_directory)        
     checksum_file = os.path.join(obj_dir, dict_name + '.pkl')     
     if os.path.isfile(checksum_file):  #if the checksum_dict file exists on disk
          #first remove all the files from checksum_dict that are no longer on disk
          total_removed = 0
          if verbose_mode:
               print('\nchecksum dictionary file found:', checksum_file)
               print('Loading checksum dictionary...')
          checksum_dict = load_obj(obj_dir, dict_name)
          if verbose_mode:
               print('checksum_dict number of elements:',len(checksum_dict))
               print('\nremoving files that are no longer on disk...')
               print('This will take a minute...')
          populate_fullfilelist(search_directory)
          number_removed = remove_files_from_checksum_dict(verbose_mode)
          total_removed += number_removed
          while number_removed > 0:
               number_removed = remove_files_from_checksum_dict(verbose_mode)
               total_removed += number_removed
          if verbose_mode:
               print('\nTotal filepaths removed: ',total_removed)
          #next add any new files on disk with checksum to checksum_dict
          if verbose_mode:
               print('\nscanning for new files on disk and adding to checksum_dict')
          number_added = add_files_to_checksum_dict(verbose_mode)
          if verbose_mode:
               print('\nTotal filepaths added: ', number_added)
               print('\nremoving all empty keys...')
          #remove all of the empty keys from the dictionary
          num_empty_keys_removed = remove_empty_dict_keys(verbose_mode)
          if verbose_mode:
               print('\nTotal empty keys removed: ', num_empty_keys_removed,'\n')
          #finally, save the updated dictionary back to disk      
          save_obj(obj_dir, checksum_dict, dict_name)          
     else:      #the checksum_dict file does not exist.  Create it.
          added_count = 0
          existing_count = 0
          #remove the contents of the current checksum_dict before building a new one
          checksum_dict.clear()
          populate_fullfilelist(search_directory)
          #populate my_checksum dictionary
          #each key contains a list of files that match that checksum
          if verbose_mode:
               print('\nChecksum file not found:', checksum_file)
               print('Calculating all checksums... this may take a while\n')          
          for x in fullfilelist:
               if verbose_mode:
                    print('Processing',x)               
               my_checksum = compute_sha1(x)               
               if my_checksum not in checksum_dict:                    
                    added_count += 1                    
                    checksum_dict[my_checksum] = [x]                    
               else:                    
                    existing_count += 1
                    checksum_dict[my_checksum].append(x)                             
          if verbose_mode:
               print('\nSuccessfullly built dictionary checksum_dict')
               print('\nLength of checksum_dict is ',len(checksum_dict))
               print('Added_count:',added_count)
               print('Existing_count:',existing_count)
          save_obj(obj_dir, checksum_dict, dict_name)
          if verbose_mode:
               print('\nSaved', checksum_file, 'to disk...\n')
          


def remove_files_from_checksum_dict(verbose_mode = True):

     '''Utility function to remove from checksum_dict all of the files that are no longer on the hard drive

     Arguments:  optional arguments verbose_mode suppresses print output if set to False

     Returns:  the number of items removed from the checksum_dict dictionary

     '''
     global checksum_dict   
     removed_items = 0     
     for check_sum in checksum_dict:              
          for list_element in checksum_dict[check_sum]:                                         
               if list_element not in fullfilelist:
                    if verbose_mode:
                         print('Removing item: ',list_element)
                    checksum_dict[check_sum].remove(list_element)                                     
                    removed_items += 1                                
     return removed_items



def add_files_to_checksum_dict(verbose_mode = True):
     '''Utility function to scan all of the files in the base filesystem and add them to
       checksum_dict if not already there

     Arguments:  verbose_mose suppresses print output if set to False

     Returns:  returns the number of items added to the checksum_dict dictionary

     '''
     global checksum_dict
     num_added_items = 0     
     for filepath in fullfilelist:
          if not file_in_checksum_dict(filepath):    #the filepath is not in the checksum_dict dictionary 
               if verbose_mode:
                    print('Adding item: ',filepath)
               computed_checksum = compute_sha1(filepath)
               if computed_checksum not in checksum_dict:   #the checksum for the file is not already in checksum_dict                                        
                    checksum_dict[computed_checksum] = [filepath]
               else:     #the checksum is already in checksum_dict - add the filepath to it
                    checksum_dict[computed_checksum].append(filepath)
               num_added_items += 1     
     return num_added_items
     

def file_in_checksum_dict(filepath):

     '''Utility function that simply returns True if a filepath is in the checksum_dict dictionary

     Arguments:  the filepath to search the dictionary for

     Returns:  true if filepath found, false otherwise

     '''
     for x in checksum_dict:
          if filepath in checksum_dict[x]:
               return True
     return False


def remove_empty_dict_keys(verbose_mode = True):

     '''Called from create_update_checksum_dict, this utility function simply removes all empty checksum_dict keys from the dictionary

     Arguments:  optional verbose_mode suppresses all print output if False

     Returns:  the number of removed keys from the dictionary

     '''
     global checksum_dict
     counter = 0
     for y in [x for x in checksum_dict if len(checksum_dict[x]) == 0]:
          if verbose_mode:
               print('removing empty key', y)
          checksum_dict.pop(y)
          counter += 1
     return counter


def display_single_checksum_files():     

     '''Randomly select a checksum_dict key that contains more than one filename as the item
        This function calls display_only_checksum_files to display the files in the chosen checksum before existing
	This function is called when we need to find and display the files for a new checksum

     Arguments:  none

     Returns:  none

     '''
     global chosen_checksum     
     if len(checksum_dict) == 0 or len([x for x in checksum_dict if len(checksum_dict[x]) > 1]) == 0:
          print('\nNo checksum duplicates found...')
          chosen_checksum = -1
          return
     checksum_list = list(checksum_dict.keys())
     found_bad = True
     while found_bad:
          chosen_checksum = random.choice(checksum_list)
          if len(checksum_dict[chosen_checksum]) > 1:
                 found_bad = False
     print(60*'-','CHECKSUM DELETE\n')     
     print('processing',chosen_checksum)    
     display_only_checksum_files()
     
                                
                    

def display_only_checksum_files():     

     '''Simply displays all of the files for the chosen checksum on screen along with a counter, size, and the checksum
        This function is called (apart from when called by display_single_checksum_file) to simply redisplay the  files matching
	the chosen checksum after the user has performed an action on the checksum file list

     Arguments:  none

     Returns:  none 

     '''
     counter = 0 
     for x in checksum_dict[chosen_checksum]:
          counter += 1
          print('{0:3d} {1:161s} {2:15d} {3}'.format(counter, x, os.path.getsize(x), compute_sha1(x)))
     print()
     




def get_checksum_file_action_menu_choice():

     '''Accepts and validates input from the list of file actions that may be taken against the list of duplicate
        files for the displayed checksum

     Arguments:  none

     Returns: the file action choice made by the user

     '''
     if chosen_checksum == -1:     #if it's -1 there is nothing left to process          
          return 'm'
     valid_choice_entered = 0
     myinput=0
     while not valid_choice_entered:
          display_file_action_instructions()
          myinput = input('\nEnter choice: ')
          if len(myinput) > 0:               
               if   myinput in ['n','m']:
                    valid_choice_entered = 1               
               elif myinput == 'dall':
                    valid_choice_entered = 1
               elif myinput[0] == 'd':
                    try:
                         mynumber = int(myinput[1:])
                    except:
                         valid_choice_entered = 0
                    else:
                         if mynumber > 0 and mynumber <= len(checksum_dict[chosen_checksum]):
                              valid_choice_entered = 1
                         else:
                              print('\nvalue entered is out of range\n')
                         
               elif myinput[0] in ('k', 'p'):
                    try:
                         mynumber = int(myinput[1:])
                    except:
                         valid_choice_entered = 0
                    else:
                         if mynumber > 0 and mynumber <= len(checksum_dict[chosen_checksum]):
                              valid_choice_entered = 1
                         else:
                              print('\nvalue entered is out of range\n')
                              
               elif myinput[0] == 'r':
                    valid_choice_entered = 1
               else:
                    valid_choice_entered = 0
     return myinput     
     
     
def execute_checksum_file_action_choice(mychoice):          

     '''Depending on the file action choice selected by the user, call the appropriate sequence of functions
        to accomplish the task
	Note that this function is recursive and should possibly be reworked to be non-recursive

     Arguments:  the file action choise entered by the user

     Returns:  none

     '''
     if   mychoice == 'm':
          print('\nreturning to main menu...')
     elif mychoice == 'n': #user wants to display the next duplicate set
          display_single_checksum_files()
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())
     elif mychoice == 'dall':
          delete_all_checksum_files()
          display_single_checksum_files()
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())         
     elif mychoice[0] == 'd': #user selects to delete a single file
          delete_checksum_single_file(int(mychoice[1:]))
          if len(checksum_dict[chosen_checksum]) == 0:
               print('\nFilename no longer exists on the disk\n')
               display_single_checksum_files()
               execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())   
          else:    
               display_only_checksum_files()
               execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())    
     elif mychoice[0] == 'k':
          keep_one_checksum_only(int(mychoice[1:]))
          display_only_checksum_files()
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())
     elif mychoice[0] == 'p':
          play_choice(checksum_dict[chosen_checksum][int(mychoice[1:])-1])
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())
     elif mychoice[0] == 'r':
          display_only_checksum_files()
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())
     else:
          print('Unknown response')
          display_single_checksum_files()
          execute_checksum_file_action_choice(get_checksum_file_action_menu_choice())



def delete_all_checksum_files():

     '''This is called when the user chooses 'dall' to delete all files from the disk  matching the current checksum
        It removes the entry from the fullfileslist list when done and pops the checksum from the dictionary

     Arguments:  none

     Returns:  none

     '''
     if len(checksum_dict[chosen_checksum]) == 0:
          print('\nNothing to delete!')
          return
     print()     
     for x in checksum_dict[chosen_checksum]:
          print('deleting ',x)
          move_copy_file('move', x, move_to_directory)
          remove_entry_from_fullfilelist(x)
     #delete this checksum from the checksum_dict dictionary
     checksum_dict.pop(chosen_checksum)
     print()
     


def delete_checksum_single_file(file_number):    

     '''This is called when the user chooses to delete a single file from the list
        It removes the file both from the fullfilelist list and checksum_dict dictionary
	as well as removing the file from the disk

     Arguments:  theh file number to delete (this is the checksum_dict key for the file)

     Returns:  none

     '''
     file_number -= 1    #convert to 0 based list
     print('\ndeleting ', checksum_dict[chosen_checksum][file_number])
     print()
     move_copy_file('move', checksum_dict[chosen_checksum][file_number], move_to_directory)
     remove_entry_from_fullfilelist(checksum_dict[chosen_checksum][file_number])
     remove_entry_from_checksum_dict(checksum_dict[chosen_checksum][file_number])
          

     
def keep_one_checksum_only(file_number):    

     '''Called when the user select k# to keep only one file from the list
        It deletes from disk all but the kept file, then restores the kept file to the checksum_dict

     Arguments:  the file number to keep (this is the checksum_dict key for the file)

     Returns:  none

     '''
     global checksum_dict
     file_number -= 1
     print()
     my_saved_item = checksum_dict[chosen_checksum].pop(file_number)     
     for x in checksum_dict[chosen_checksum]:         
          print('deleting ', x)          
          move_copy_file('move', x, move_to_directory)
          remove_entry_from_fullfilelist(x)          
     print()
     checksum_dict[chosen_checksum] = [my_saved_item] 


def remove_entry_from_checksum_dict(my_filename):

     '''Removes a filepath from the checksum_dict dictionary

     Arguments:  the filepath to remove

     Returns: none

     '''
     global checksum_dict
     checksum_dict[chosen_checksum].remove(my_filename)



#------------------------------------------------------------------------------------------------------------
#  Process an extension
#-----------------------------------------------------------------------------------------------------------


#this section allows the user to delete all files of a particular extension (filetype) from the
#base filesystem.  It also allows the user to specify the maximum file size to delete


def process_extension(): 

     '''Ask the user for a file extension and maximum size
        Call function 'get_list_of_extension' to fill list all_file_of_extension with all of the files that match the criteria
	Ask the user to confirm that they want to proceed
	If ok to proceed, delete all files in list all_file_of_extension else abort and return to the main menu

     Arguments:  none

     Returns:  none

     '''
     global refresh_filelist_req
     start_pos = len(my_homedir) + 1
     my_exten = input('\nEnter extension to delete (no leading dot): ')
     my_exten = '.' + my_exten
     valid_input = False
     while not valid_input:
          limit_by_size = input('Input maximum size in bytes (zero for all): ')
          try:
               size_limit = int(limit_by_size)
          except:
               pass
          else:
               if size_limit >= 0:
                    valid_input = True     
     all_file_of_extension = get_list_of_extension(my_exten,size_limit)
     if len(all_file_of_extension) == 0:
          print('\nNo files found with that extension')
          return
     else:
          print('\nThe following files will be deleted:\n')
          for x in all_file_of_extension:
               print('{0:161s} {1:15d}'.format(x[start_pos:], os.path.getsize(x)))
          print('\nYou are about to delete all listed files with extension',my_exten)
          confirm = 't'
          while confirm.lower() not in ('y', 'n'):
               confirm = input('Are you sure (y or n)? ')
          if confirm == 'n':
               print('\nAborting delete...')
               return
          else:
               print()
               for x in all_file_of_extension:
                    print('deleting ', x)
                    move_copy_file('move', x, move_to_directory)
               print('\nTotal files deleted: ',len(all_file_of_extension))
               refresh_filelist_req = 1      #filelist needs to be refreshed since we've deleted a bunch of files
     

def get_list_of_extension(my_extension, size_limit):    

     '''Populate list all_file_of_extension with a list of filepaths to delete based on the chosen criteria

     Arguments:  the extension to delete and the maximum file size to delete 

     Returns:  list all_file_of_extension (containing all filepaths to delete)

     '''
     all_file_of_extension = []
     counter=0  
     for root, dirs, files in os.walk(search_directory):
          for myfile in files:
               counter += 1
               shortname, extension = os.path.splitext(myfile)   #shortname is filename w/o extension, extension = extension              
               file_size = os.path.getsize(os.path.join(root, myfile))
               if size_limit > 0:                   
                    if extension == my_extension and file_size <= size_limit:
                         all_file_of_extension.append(os.path.join(root, myfile))
               else:
                    if extension == my_extension:
                         all_file_of_extension.append(os.path.join(root, myfile))
     return all_file_of_extension
                    
                         

#---------------------------------------------------------------------------------------------------------------
#  Remove empty directories
#---------------------------------------------------------------------------------------------------------------

#this section just cleans up all empty directories that have no files beneath them



def remove_empty_directories(root_dir=search_directory):     

     '''Remove all empty directories recursively beneath the given directory

     Arguments:  optional argument specifies the base filesystem to scan else defaults to the global search_directory

     Returns: none

     '''
     dirs_removed = 0 
     print('\nRemoving all empty directories from path', root_dir, '...')          
     for root, dirs, files in os.walk(root_dir):
          for dir in dirs:
               newdir = os.path.join(root, dir)        
               try:
                    os.removedirs(newdir)            
               except:
                    pass
               else:
                    print('Deleting ',newdir)         
                    dirs_removed += 1
     print('\nNumber empty directories deleted: ',dirs_removed)
     return


#---------------------------------------------------------------------------------------------------------------------
#  Display file stats
#---------------------------------------------------------------------------------------------------------------------


#This option allows the user to view various stats about the current base filesystem.
#Stats include number of files, total file size, number of duplicates, etc.


def display_file_stats():

     '''Call all required functions to compute the required statistics, then print out the results

     Arguments:  none

     Returns:  none

     '''
     global refresh_filelist_req
     refresh_filelist_req = 1
     print('\nCalculating... this may take a minute')
     print('Showing statistics for', search_directory)    
     num_files, num_unique = find_dups(print_stats = False)
     used = get_total_file_size()
     create_update_checksum_dict(verbose_mode = False)
     unique_checksum, non_unique_checksum, num_nec = calculate_checksum_stats()     
     readable_size = '(' + approximate_size(used) + ')'
     print('\n**************File Statistics*******************')
     print('{0:40s} {1:n} {2}'.format('Total space used by files in bytes:', used, readable_size))
     print('{0:40s} {1:n}'.format('Total number of files:', num_files))
     print('{0:40s} {1:n}'.format('Number of unique filenames:', num_unique))
     print('{0:40s} {1:n}'.format('Number of duplicate filenames:', num_files - num_unique))
     print('{0:40s} {1:n}'.format('Number of checksum unique files:', unique_checksum))
     print('{0:40s} {1:n}'.format('Number of checksum duplicate files:', non_unique_checksum))
     print('{0:40s} {1:n}'.format('Average files per checksum:', num_files/num_nec))
    


def calculate_checksum_stats():

     '''Computer various checksum statstics

     Arguments:  none

     Returns:  # of unique checksum files, # of multiple checksum files, and the number of non empty checksums

     '''
     unique_checksum_files = 0
     multiple_checksum_files = 0
     number_non_empty_checksums = 0
     for x in checksum_dict:
          if len(checksum_dict[x]) == 1:
               unique_checksum_files += 1
               number_non_empty_checksums += 1
          elif len(checksum_dict[x]) > 1:
               multiple_checksum_files += 1
               number_non_empty_checksums += 1
     return (unique_checksum_files, multiple_checksum_files, number_non_empty_checksums)
     


def approximate_size(size, a_kilobyte_is_1024_bytes=True):

    '''Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- If True (default), use multiples of 2014
                                If False, use multiples of 1000

    Returns: string

    '''
    SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}
    if size < 0:
        raise ValueError('number must be non-negative')
    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size < multiple:
            return '{0:.1f} {1}'.format(size, suffix)
    raise ValueError('number too large')

def get_total_file_size():

     '''Add up the sizes of all files in the base filesystem (recursive)

     Arguments:  none

     Returns:  The total file size

     '''
     total_size = 0
     for x in fullfilelist:
          total_size += os.path.getsize(x)
     return total_size
              


#----------------------------------------------------------------------------------------------------------------------
#  Stack filetypes
#----------------------------------------------------------------------------------------------------------------------

#This option allows the user to copy or moves files from any chosen directory to any other chosen directory
#It allows migration of all files or only files of a particular extension
#All files are 'stacked' at their destination under a folder indicating the extensions of the files within.


def stack_filetypes():
	
     '''Call all required functions to stack filetypes
     
     Arguments:  none
     
     Returns:  none
     
     '''
     source_dir, target_dir, action, acting_extension = get_source_and_destination()
     extension_set = determine_all_filetypes(source_dir, acting_extension)
     print('extension_set is', extension_set)
     success = create_target_directories(target_dir, extension_set)     
     if success:
          move_or_copy_extension_files(target_dir, action, extension_set)
          if action == 'move':
               remove_empty_directories(root_dir=source_dir)


def get_source_and_destination():
     '''Get the source directory, the target directory, whether to copy or move, and which extension
        to migrate from the user.  Allow the user to type 'current' to use the current directory.
		
     Arguments:  none
	 
     Returns:  the source directory, target directory, requested action, and the requested extension
	 
     '''
     global refresh_filelist_req
     not_found = True
     print('\nSpecify the source (where the files are coming from) directory name as an absolute path')
     print('Your current directory is ', os.getcwd())
     print('To use your current directory type current')
     while not_found:
          source_dir = input('Enter source directory: ')
          if source_dir == 'current':
               source_dir = os.getcwd()
               not_found = False
          elif os.path.isdir(source_dir):
               not_found = False
     print('\nSpecify an absolute path target (where the files will be moved to) directory name ')
     print('Your current directory is ', os.getcwd())
     print('To use your current directory type current')
     target_dir = input('Enter target directory: ')
     if target_dir == 'current':
          target_dir = os.getcwd()
     print('\nType move to move the files or copy to copy the files')
     action_requested = ''
     while action_requested not in ('move', 'copy'):          
          action_requested = input('move or copy: ')
     if action_requested == 'move':
          refresh_filelist_req = 1
     print('\nSpecify whether to copy/move all or a specific extension (no leading dot) ')
     acting_extension = input('Enter extension or all for everything: ')
     if not acting_extension == 'all':
          acting_extension = '.' + acting_extension
     return source_dir, target_dir, action_requested, acting_extension



def determine_all_filetypes(source_dir, acting_extension):
	
     '''Traverse the source directory recursively and add all files matching the selection
        criteria to a set called extension_set
		
     Arguments:  the source directory and the extension to act on
	 
     Returns:  returns the set extension_set that contains all files matching the criteria
 
     '''
     extension_set = set()
     populate_fullfilelist(source_dir)     
     for x in fullfilelist:
          (dirname, filename) = os.path.split(x)
          shortname, extension = os.path.splitext(filename)          
          if extension == '':
               extension = '.no_exten'
          if acting_extension == 'all':
               extension_set.add(extension[1:])
          else:
               if acting_extension.lower() == extension.lower():
                    extension_set.add(extension[1:])                    
     return extension_set
           
                     
def create_target_directories(target_dir, extension_set): 
	
     '''Create the target directory and all of the extension directories in it
	 
     Arguments:  the target directory and the extension set set
	 
     Returns:  returns True if everything was created successfully, else false
	 
     '''
     if not os.path.isdir(target_dir):  
          try:
               os.mkdir(target_dir)
          except:
               print('\nError occurred when creating target directory.  Returning to main menu')
               return False                                 
     for x in extension_set:
          path_to_create = os.path.join(target_dir, x)          
          try:
               os.mkdir(path_to_create)
          except FileExistsError:  #continue if the directory already exists
               pass
     return True
     


def move_or_copy_extension_files(target_dir, action, extension_set):  
	
     '''Move or copy all files in set extension_set to the destination folder 
        under the appropriate extension folder
		
     Arguments:  the target directory and the extension set set
	 
     Returns:  none
	 
     '''
     verb = 'copying' if action == 'copy' else 'moving'
     number_moved = 0
     for my_extension in extension_set:
          extension_with_dot = '.' + my_extension
          print('\nprocessing extension ', my_extension)
          cur_target_dir = os.path.join(target_dir, my_extension) + '/'          
          for x in fullfilelist:
               (dirname, filename) = os.path.split(x)
               shortname, extension = os.path.splitext(filename)
               if extension == '':
                    extension = '.no_exten'
               if extension == extension_with_dot:
                    print(verb, x, 'to', cur_target_dir)                    
                    move_copy_file(action, x, cur_target_dir)
                    number_moved += 1
     print('\nTotal number of files found and copied/moved: ', number_moved)
     


#-------------------------------------------------------------------------------------------------------------------
# Move or copy files
#-------------------------------------------------------------------------------------------------------------------


#Allows the user to either move or copy files (all or only a particular extension)
#Very similar to stacking except all of the files are put directly in the destination directory.
#This option can be used to 'flatten' directory hierarchies by bringing everything up to
#the current directory


def move_or_copy_files():

     '''Call of the required functions to do the copy/move

     Arguments:  none

     Returns:  none

     '''
     source_dir, target_dir, action, acting_extension = get_source_and_destination()
     files_to_move = get_files_to_act_on(source_dir, acting_extension, target_dir)     
     success = create_target_if_required(target_dir)
     if success:
          do_file_moves(files_to_move, action, target_dir)
          if action == 'move':
               remove_empty_directories(root_dir=source_dir)
     

def get_files_to_act_on(source_dir, acting_extension, target_dir):

     '''Fill a list 'files_to_move' with all of the files that are to be copied/moved

     Arguments:  The source directory (string), acting_extension (string) and the target directory (string)

     Returns:  files_to_move (a list)

     '''
     files_to_move = []
     counter=0   
     for root, dirs, files in os.walk(source_dir):
          for myfile in files:
               dirname, filename = os.path.split(myfile)
               shortname, extension = os.path.splitext(filename)
               if source_dir == target_dir:
                    if root != source_dir:
                         if acting_extension == 'all':
                              files_to_move.append(os.path.join(root, myfile))     
                         else:
                              if acting_extension.lower() == extension.lower():
                                   files_to_move.append(os.path.join(root, myfile))
               else:
                    if acting_extension == 'all':
                              files_to_move.append(os.path.join(root, myfile))     
                    else:
                         if acting_extension.lower() == extension.lower():
                              files_to_move.append(os.path.join(root, myfile))                    
     return files_to_move


def create_target_if_required(target_dir):

     '''if necessary, create the target directory

     Arguments:  the target directory to create (string)

     Returns:  True if the directory was either created or already exists, false otherwise

     '''
     if not os.path.isdir(target_dir):  
          try:
               os.mkdir(target_dir)
          except:            
               print('\nError creating directory: ', target_dir)
               return False
     return True
          
     
def do_file_moves(files_to_move, action, target_dir):

     '''For each of the files in list files_to_move, call function
        move_copy_file to do the move or copy.  Print out how many files were migrated

     Arguments:  files_to_move (list), action (string containing either move or copy), target directory (string)

     Returns:  none

     '''
     verb = 'copying' if action == 'copy' else 'moving'
     number_moved = 0
     for x in files_to_move:
          print(verb, x, 'to', target_dir + '/') 
          move_copy_file(action, x, target_dir + '/')
          number_moved += 1
     print('\nTotal number of files found and copied/moved: ', number_moved)
     


#--------------------------------------------------------------------------------------------------------------------
# Change active directory
#--------------------------------------------------------------------------------------------------------------------

#Simply changes the global variable search_directory that contains the base directory for many options


def change_active_directory():

     '''Ask the user for the base directory and set global variable search_directory to that.
        Write the new base directory to file '~/.gordutils/gu_working_path

     Arguments:  none

     Returns:  none

     '''
     global search_directory, refresh_filelist_req
     base_dir_exists = False
     gordutils = os.path.join(my_homedir, '.gordutils')     
     work_dir_file = os.path.join(gordutils, 'gu_working_path')    
     print('\nPlease enter the directory containing the file system you want to act on: ')
     while not base_dir_exists:
          mydir = input('directory: ')
          if os.path.exists(mydir):
               base_dir_exists = True     
     search_directory = mydir
     with open(work_dir_file, mode='w', encoding='utf-8') as base_file:
               base_file.write(mydir)    
     print('\nBase directory set to', search_directory)
     print('This is permanent until reset with option #8')
     refresh_filelist_req = 1
     
     

#----------------------------------------------------------------------------------------------------------------------
#  Print working directory
#----------------------------------------------------------------------------------------------------------------------

#print out the current base directory


def print_working_directory():

     '''Print the current base directory

     Arguments: none

     Returns:  none

     '''
     print('\nCurrent active directory: ',search_directory)



#----------------------------------------------------------------------------------------------------------------------
#  Checkout files
#----------------------------------------------------------------------------------------------------------------------

# This option allow you to specify a type of file and copy all files of that extension to a 'checkout' directory
# You are then free to use a graphical tool to look at the files in the checkout directory.
# This is especially useful for looking for duplicate pictures with different resolutions.
# Once you have finished deleted everything you don't want from the checkout dir., you use the next
# option to check the files back in.  Everything you deleted in the checkout directory is deleted in the
# source directory you checked out from



def checkout_files():

     '''Function to call other functions to checkout the files
     
     Arguments: none

     Returns:  none

     '''
     keep_going = check_destination_directory()
     if keep_going:
          source_dir, requested_extension = get_source_and_extension()
          target_dir = my_homedir + '/checkout_dir/'
          print('\nThe files will be copied to directory: ', target_dir) 
          files_to_checkout = create_file_checkout_list(source_dir, target_dir, requested_extension)
          copy_count = special_copy_files_to_checkout(files_to_checkout)          
          if not copy_count == 0:
               print('\nSuccessfully checked out', copy_count, 'files')
               write_checkout_filelist_to_disk(files_to_checkout)
          else:
               print('\nNo files found to checkout')
               print('Checkin operation not possible')


def check_destination_directory():

     '''Checks to make sure the checkout directory is empty before beginning.  If not
        the user can either delete the contents or abort the operation
     
     Arguments:  none

     Returns: Returns True if it is ok to proceed with the checkout operation

     '''
     # the destination directory needs to be emtpy before beginning
     myinput = ''
     target_dir = my_homedir + '/checkout_dir/'
     if os.path.isdir(target_dir):     
          if not os.listdir(target_dir) == []:     #the target directory is not empty
               print('\nDestination directory ',target_dir, ' is not empty')
               myinput = input('Is it ok to delete everything in this directory (y or n)? ')
               while myinput not in ('y', 'n'):
                    myinput = input('(y or n) ')
               if myinput == 'n':
                    print('\nCannot continue without empty directory.  Returning to main menu...')
                    return False
               else:   #delete contents of checkout destination directory                    
                    cleanup_checkout_dir(target_dir)                    
                    return True
          else:
               return True
     else:
          os.mkdir(target_dir)
          return True
               

def get_source_and_extension():    

     '''Asks the user for the source directory and the extension to check out

     Arguments:  none

     Returns:  the source directory (string) and the request_extension (string)

     '''
     not_found = True
     print('\nSpecify the source directory to checkout the files from (as an absolute path)')
     print('Your current directory is ', os.getcwd())
     print('To use your current directory type current')
     while not_found:
          source_dir = input('Enter source directory: ')
          if source_dir == 'current':
               source_dir = os.getcwd()
               not_found = False
          elif os.path.isdir(source_dir):
               not_found = False              
     print('\nSpecify the filetype to checkout (no leading dot)')
     requested_extension = input('Extension to checkout: ')
     requested_extension = '.' + requested_extension
     return source_dir, requested_extension



def create_file_checkout_list(source_dir, target_dir, requested_extension):

     '''Adds all files with the requested extension to the files_to_checkout list

     Arguments:  The source directory (string), target dir (string),
                 and the requested_extension (string)

     Returns:  files_to_checkout (list containing all of the filepaths to copy 
               to the destination directory

     '''
     files_to_checkout = []
     counter=0   
     requested_extensions_to_copy = get_extension_list(requested_extension)
     for root, dirs, files in os.walk(source_dir):
          for myfile in files:
               dirname, filename = os.path.split(myfile)
               shortname, file_extension = os.path.splitext(filename)
               if file_extension.lower() in requested_extensions_to_copy:
                    checkout_name_list = [os.path.join(root, myfile)]
                    files_to_checkout.append(checkout_name_list)                                 
     return files_to_checkout


def get_extension_list(requested_extension):

     '''Add related extensions to the one chosen by the user
        For example if the user types jpg, we also want to checkout jpeg files

     Arguments:  requested_extension (string) supplied by the user

     Returns:  requested_extension (list) containing all extensions to copy

     '''
     if requested_extension.lower() in ('.jpg', '.jpeg'):
          return ['.jpg', '.jpeg']
     else:
          return [requested_extension.lower()]


def special_copy_files_to_checkout(files_to_checkout):

     '''Copy all files in list files_to_checkout to the destination directory
        This operation also appends the destination filepath to each already
	existing filepath in the files_to_checkout list
	After this, files_to_checkout is a list of lists, with each element
	a source and destination filepath

     Arguments:  files_to_checkout (list containing all files to copy to dest, dir.)

     Returns:  count of how many files were copied

     '''
     copy_count = 0
     dest_directory = my_homedir + '/checkout_dir/'
     for x in files_to_checkout:          
          (dirname, filename) = os.path.split(x[0])   #filename is the filename only
          shortname, extension = os.path.splitext(filename)   #shortname is filename w/o extension, extension = extension
          destination_file = os.path.join(dest_directory, filename)
          counter = 1
          while os.path.isfile(destination_file):        
               destination_file = dest_directory + shortname + '(' + str(counter) + ')' + extension        
               counter += 1
          #now that destination is a unique filename, the call to copy should work
          print('copying ', x[0], ' to ', destination_file)
          shutil.copy2(x[0], destination_file, follow_symlinks=False)
          x.append(destination_file)
          copy_count += 1
     return copy_count


def write_checkout_filelist_to_disk(files_to_checkout):

     '''After copying all of the files to the checkout directory, save the files_to_checkout list
        to a file so it can be read when the user wants to check the files back in

     Arguments:  files_to_checkout (list of lists of files to checkout and the destination filename)

     Returns:  none

     '''
     file_dir = os.path.join(my_homedir,'.gordutils')
     save_obj(file_dir, files_to_checkout, 'checkout_file')
     

#----------------------------------------------------------------------------------------------------------------------
#  Checkin files
#----------------------------------------------------------------------------------------------------------------------

# This is the 'sister' operation to checkout_files.  It simply scans the checkout directory to find out
# which files were deleted, then deletes those same files from the source directory


def checkin_files():

     '''Read the checkout list to list my_checkout_list, then for each file that is no longer
        in the checkout directory, delete the corresponding source file from the source directory

     Arguments:  none

     Returns:  none

     '''
     num_deleted = 0
     #check to see if the checkout files exists before trying to load it
     file_dir = os.path.join(my_homedir,'.gordutils')
     checkout_file = os.path.join(file_dir, 'checkout_file.pkl')
     if not os.path.exists(checkout_file):
          print('\nCheckout file does not exist')
          print('You must use the checkout files option first...')
          return
     #load the checkout list
     my_checkout_list = load_obj(file_dir, 'checkout_file')     
     # for each destination file, check if it is there
     # if it's not there, remove it from the base file system
     print()
     for x in my_checkout_list:
          if not os.path.isfile(x[1]):  #the file has been deleted from the checkout directory               
               print('deleting ', x[0])
               move_copy_file('move', x[0], move_to_directory)
               num_deleted += 1
     print('\nDeleted', num_deleted, 'files from source directory')
     #delete the checkout_file and contents of checkout_dir from disk since we are done with it
     cleanup_checkout_dir(os.path.join(my_homedir, 'checkout_dir'))
          
     

#----------------------------------------------------------------------------------------------------------------------
#  Utility functions
#----------------------------------------------------------------------------------------------------------------------


def save_obj(file_dir, obj, name ):

     '''dump an object out to disk using pickle

     Arguments:  destination directory (string), object to save (object), name of file (string)

     Returns:  non

     '''
     file_dir = file_dir + '/'
     with open(file_dir + name + '.pkl', 'wb') as f:
          pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)
     

def load_obj(file_dir, name ):

     '''Load an object from disk

     Arguments:  directory to load from (string), name of file to load (string)

     Returns:  the oject read from the disk

     '''
     file_dir = file_dir + '/'
     with open(file_dir + name + '.pkl', 'rb') as f:
          return pickle.load(f)

def compute_sha1(filename):

     '''Compute the SHA1 checksum of a file

     Arguments:  the filename to compute the checksum of (string)

     Returns:  the hash (checksum)

     '''
     blocksize = 65536
     hasher = hashlib.sha1()
     with open(filename, 'rb') as afile:
          buf = afile.read(blocksize)
          while len(buf) > 0:
               hasher.update(buf)
               buf = afile.read(blocksize)
     return hasher.hexdigest()


def populate_fullfilelist(dirsearch):

     '''Read all files from and below a specified path recursively into 
        list fullfilelist

     Arguments:  the directory to read in (string)

     Returns:  none

     '''
     global fullfilelist
     del fullfilelist[:]     
     counter=0   
     for root, dirs, files in os.walk(dirsearch):
          for myfile in files:
             counter += 1
             fullfilelist.append(os.path.join(root, myfile))

def display_file_action_instructions():

     '''Display the file action choices to the screen

     Arguments:  none

     Returns:  none

     '''
     print('To delete a specific file, enter d#')
     print('To delete all items, enter dall')
     print('To keep only one item, enter k#')
     print('To continue with the next duplicate item, press n')
     print('To return to the main menu, press m')


def delete_item_from_disk(item):

     '''Deletes a specified file from the hard drive

     Arguments:  the item (file) to delete (string)

     Returns:  none

     '''
     try:
          os.remove(item)  #delete the requested file from the disk
     except:
          print('Error encountered in deleting file ',item)
          print('exiting...')
          sys.exit(1)


def move_copy_file(action, item, dest_directory):

     '''Moves a file from a source to a destination direcotyr

     Arguments:  the action to take - copy or move (string)
                 the item to move (string)
		 the destination to move to

     Returns:  True if successful, False otherwise

     '''
     #this function moves a file from source to a destination directory
     #if the file exists it won't overwrite so we need to tack on a numeric extension to make it unique
     (dirname, filename) = os.path.split(item)   #filename is the filename only
     shortname, extension = os.path.splitext(filename)   #shortname is filename w/o extension, extension = extension
     destination = os.path.join(dest_directory, filename)
     counter = 1
     while os.path.isfile(destination):        
        destination = dest_directory + shortname + '(' + str(counter) + ')' + extension        
        counter += 1
     #now that destination is a unique filename, the call to move should work
     if action == 'move':
          try:
               shutil.move(item, destination)
          except:
               return False
          else:
               return True
     elif action == 'copy':
          try:
               shutil.copy2(item, destination, follow_symlinks=False)
          except:
               return False
          else:
               return True
     else:
          print('Invalid action passed to move_copy_file: ',action)
          sys.exit(1)


def remove_entry_from_fullfilelist(entry):

     '''Utility function to simply remove a filepath from list fullfilelist

     Arguments:  the filepath to remove

     Returns:  none

     '''
     global fullfilelist
     fullfilelist.remove(entry)


def replace_slash_with_underscore(mystring):

     '''Utility function to replace all /'s in a string with underscores
        The first and last character are removed if they are /'s

     Arguments:  the string to convert (string)

     Returns:  the converted string
   
     '''
     mystring = mystring.replace('/', '_')
     if mystring[0] == '_':
          mystring = mystring[1:]
     if mystring[-1] == '_':
          mystring = mystring[:-2]
     return mystring


def play_choice(mychoice):   #launch a program to play or view the chosen file       

     '''Calls either feh to display an image or ffplay to play an audio file

     Arguments:  the filepath to play/display

     Returns:  none

     '''
     (dirname, filename) = os.path.split(mychoice)   #filename is the filename only
     shortname, extension = os.path.splitext(filename)     
     if extension.lower() in ('.jpg', '.jpeg', '.png', '.bmp', '.gif'):
          my_command = 'feh --scale-down ' + '"' + mychoice + '"'              
          os.system(my_command)
     elif extension.lower() in ('.mp4', '.mov', '.avi', '.mp3', '.wav'):
          my_command = 'ffplay ' + '"' + mychoice + '"'
          os.system(my_command)
          


def cleanup_checkout_dir(target_dir):

     '''Remove the checkout_file and contents of checkout_dir 
        to cleanup after a checkout/checkin operation

     Arguments:  the target directory (the checkout directory) (string)

     Returns:  none

     '''
     for x in os.listdir(target_dir):
          file_to_delete = os.path.join(target_dir, x)
          delete_item_from_disk(file_to_delete)
     if os.path.exists(os.path.join(my_homedir, '.gordutils', 'checkout_file.pkl')):     
          delete_item_from_disk(os.path.join(my_homedir, '.gordutils', 'checkout_file.pkl'))



def first_time_setup():

     '''Do first time setup as necessary
        Create directory ~/.gordutils
	If gu_working_path already exists read it to set the working directory
	Create ~/.gordutils/gu_working_path and populate with base directory
	Create ~/gordutils_deleted to move deleted files to

     Arguments:  none

     Returns:  none

     '''
     global search_directory, move_to_directory     
     base_dir_exists = False
     gordutils = os.path.join(my_homedir, '.gordutils')
     if not os.path.isdir(gordutils):
          os.makedirs(gordutils)
     work_dir_file = os.path.join(gordutils, 'gu_working_path')
     if not os.path.exists(work_dir_file):   #first use of the program          
          print('\nPlease enter the directory containing the file system you want to act on: ')
          while not base_dir_exists:
               mydir = input('directory: ')
               if os.path.exists(mydir):
                    base_dir_exists = True
          print('\nUsing', mydir, 'as base directory')
          search_directory = mydir
          with open(work_dir_file, mode='w', encoding='utf-8') as base_file:
                    base_file.write(mydir)
     else:     #the program has been run before
          with open(work_dir_file, encoding='utf=8') as base_file:
               search_directory = base_file.read()
          print('\nBase directory is', search_directory)
     #create the move_to_directory
     move_to_directory = os.path.join(my_homedir, 'gordutils_deleted') + '/'     
     if not os.path.exists(move_to_directory):
          os.makedirs(move_to_directory)                    
          
     
          

#-----------------------------------------------------------------------------------------------------------
#  Main
#-----------------------------------------------------------------------------------------------------------


if __name__ == '__main__':

     '''Main function:  only executes if this module is called directly

     Arguments:  none

     Returns:  none

     '''
     first_time_setup()
     while True:
          main_menu_choice = get_main_choice()
          execute_main_choice(main_menu_choice)




